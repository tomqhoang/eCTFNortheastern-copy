#!/usr/bin/env python

"""
Memory Readback Tool
A frame consists of four sections:
1. Thirty two bytes for the password.
2. Eight bytes for the start address.
3. Eight bytes for the number of bytes to read.
4. Thirty two bytes for SHA256 representation.

Total is 80 bytes

[ 0x20 ]  [ 0x08 ]    [ 0x08 ]   [ 0x20 ]
-------------------------------------------------
 Password | Start Addr | Num Bytes | SHA256
-------------------------------------------------
"""

import argparse
import binascii
import json
import serial
import struct
import sys
import argparse
import binascii
import math

from hashlib import sha256
from simon import SimonCipher

RESP_OK = b'\x00'
RESP_ERROR = b'\x01'

# Swaps bytes in a list, see StackOverflow
def swap_order(d, wsz=4, gsz=2 ):
        return "".join(["".join([m[i:i+gsz] for i in range(wsz-gsz,-gsz,-gsz)]) for m in [d[i:i+wsz] for i in range(0,len(d),wsz)]])

def swap_and_simon(value, simon, function):
    """
    This is a function that encrypts a value with len(value) 0 to 16
    to a 16 char encrypted string
    Param
    ---------
    value : int or string
        value to encrypt
    simon : SimonCipher
        Cipher used to encrypt data
    Returns
    ----------
    sting
        encrypted string
    """
    # Ensure that the value to be encrypted/decrypted is 8 bytes, or 16 hex characters 
    value = str(value)
    if len(value) > 16 and len(value) < 0:
        print "Not a valid length for encryption/decryption"
        sys.exit(1)
    #print("original val: "+ value.zfill(16))
    valueSwapped = swap_order(value.zfill(16),wsz=16,gsz=2)
    #print("swapped val: "+ valueSwapped)
    if function == 'encrypt':
    	valueEncrypted = hex(simon.encrypt(int(valueSwapped,16)))[2:-1]  # Encrypt the start address
    	valueFinal = swap_order(valueEncrypted.zfill(16),wsz=16,gsz=2)
    	#print("valueFinal : "+ valueFinal)
    elif function == 'decrypt':
	valueDecrypted = hex(simon.decrypt(int(valueSwapped, 16)))[2:-1] 
	valueFinal = swap_order(valueDecrypted.zfill(16), wsz=16, gsz=2)
    else:
	print("Error: specify encryption or decryption")
	sys.exit()
    return valueFinal

def create_simon():
    
    # Read in secret password from file
    SIMON_KEY = ''
    try:
        with open('secret_configure_output.txt', 'rb') as secret_file:
	    # load the secret file into a python dictionary
            jsondict = json.loads(secret_file.read())
            SIMON_KEY = jsondict["SIMONKEY"]
    except:
        print("file not found")
        pass


    # Encrypt and create the frames
    first_keyq = swap_order(SIMON_KEY[0:8], wsz=8, gsz=2)
    second_keyq = swap_order(SIMON_KEY[8:16], wsz=8, gsz=2)
    third_keyq = swap_order(SIMON_KEY[16:24], wsz=8, gsz=2)
    fourth_keyq = swap_order(SIMON_KEY[24:32], wsz=8, gsz=2)
    # Reverse order of chunks to play nice with simon library
    swap_key = fourth_keyq + third_keyq + second_keyq + first_keyq

    # Create a SimonCipher object with a key, keysize, and blocksize
    simon = SimonCipher(int(swap_key, 16), key_size=128, block_size=64)

    return simon


def construct_request(start_address, num_bytes):
    """
    function that constructs request package
    Param
    -------
    start_address: int
        the start of the memory address
    num_bytes: int
        the number of bytes to return
    Returns:
    package
        ready to send package
    """
    # Since we currently have the decimal value for start_address and num_bytes, we 
    # need to change them back to hex strings and remove the leading '0x'
    start_address = hex(start_address)[2:]    
    num_bytes = hex(num_bytes)[2:]

    print("Num_bytes after casting magic: " + num_bytes)

    simon = create_simon()
    
    # Read in secret password from file
    SECRET_PASSWORD = ''
    try:
        with open('secret_configure_output.txt', 'rb') as secret_file:
	    # load the secret file into a python dictionary
            jsondict = json.loads(secret_file.read())
            SECRET_PASSWORD = jsondict["password"]
    except:
        print("file not found")
        pass

    # Encrypt frame by frame using simon
    block1 = swap_and_simon(SECRET_PASSWORD[0:16], simon, 'encrypt')
    block2 = swap_and_simon(SECRET_PASSWORD[16:32], simon, 'encrypt')
    block3 = swap_and_simon(SECRET_PASSWORD[32:48], simon, 'encrypt')
    block4 = swap_and_simon(SECRET_PASSWORD[48:], simon, 'encrypt')

    # Encrypt the initial memory location
    memory_location = swap_and_simon(start_address, simon, 'encrypt')
    # Encrypt the number of bytes that we want to read
    length_data = swap_and_simon(num_bytes, simon, 'encrypt')
    print("Num_bytes " + str(num_bytes))
    print("Encrypted num bytes " + str(length_data))
    # Combine the 4 sections, start address, and number of bytes into one package
    complete_package = block1 + block2 + block3 + block4 + memory_location + length_data
    print("FINAL FRAME : " + complete_package)
    print("Final frame length: " + str(len(complete_package)))
    print("Frame type: " + str(type(complete_package)))

    # Generate hash of final packaged data
    final_package_hash = sha256(complete_package.decode('hex')).hexdigest().zfill(64)

    print("HASH : " + final_package_hash)
    print("Hash type: " + str(type(final_package_hash)))
    package_hash = final_package_hash
    #Big Endian 48byte for final frame and 32byte for hash
    package = struct.pack('>48s32s',  binascii.unhexlify(complete_package), binascii.unhexlify(package_hash))
    print("Package Hash: " + package_hash)
    a, b = struct.unpack('>48s32s', package)
    print("password, start address, num_bytes : " + binascii.hexlify(a))
    print("SHA : " + binascii.hexlify(b))
    return package

if __name__ == '__main__':
    """
    Main Function
    """
    parser = argparse.ArgumentParser(description='Memory Readback Tool')
    parser.add_argument("--port", help="Serial port to send update over.", required=True)
    parser.add_argument("--address", help="First address to read from (in hex)", required=True)
    parser.add_argument("--num-bytes", help="Number of bytes to read (in hex)", required=True)
    parser.add_argument("--datafile", help="File to write data to (defaults to readback_output.hex).", default="readback_output.hex")
    args = parser.parse_args()

    print(str(args.num_bytes))
    print("Start address: " + str(args.address))

    request = construct_request(int(args.address, 16), int(args.num_bytes, 16))

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    ser = serial.Serial(args.port, baudrate=115200, timeout=2)

    # Wait for bootloader to reset/enter readback mode.
    print("Waiting for bootloader...")
    while ser.read(1) != 'R':
        pass

    # Send the request.
    ser.write(request)
    print("Request sent.")

    # Read the data
    print("Waiting to receive an 'R'....")
    while ser.read(1) != 'R':
        pass

    # round num_bytes up to nearest 8 and read that many
    rounded_num_bytes = int(8*math.ceil(float(int(args.num_bytes, 16))/8))
    print(str(rounded_num_bytes))
    data = ser.read(rounded_num_bytes).encode('hex')
    print(data)

    # create a simon object for use with the decryption function
    simon = create_simon()   

    start_addr = hex(int(args.address, 16))[2:]
 
    with open(args.datafile, 'wb+') as datafile:
	# Break the data up into 8-byte (16 hex char) chunks
	chunk_size = 16
	num_chunks = len(data)/16
	segmented_data = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        # write the start address (increment by 0x10 each time) as a 5-char hex string
	for i in range(num_chunks-1):
	    print("Original data: " + str(segmented_data[i]))
	    # decrypt the chunk
	    decrypted_chunk = swap_and_simon(segmented_data[i], simon, 'decrypt')
	    print("Decrypted data: " + str(decrypted_chunk))
	    # update the start address
	    updated_addr = hex(int(start_addr, 16) + 8*i)[2:]
	    # write the start address and chunk to the file
	    datafile.write(str(updated_addr) + str(decrypted_chunk) + str('\n'))
	    
        # for the last one, decrypt and remove the zero-padding
	print("Original data: " + str(segmented_data[num_chunks-1]))
	decrypted_chunk = swap_and_simon(segmented_data[num_chunks-1], simon, 'decrypt')
	print("Decrypted data: " + str(decrypted_chunk))
	num_zero_bytes = rounded_num_bytes - int(args.num_bytes, 16)
	new_length = 16 - 2*num_zero_bytes
        decrypted_chunk = decrypted_chunk[0:new_length]
	print("Removed the zeros: " + str(decrypted_chunk))
	updated_addr = hex(int(start_addr, 16) + 8*(num_chunks-1))[2:]
	datafile.write(str(updated_addr) + str(decrypted_chunk))
