#!/usr/bin/env python

"""
Memory Readback Tool

A frame consists of four sections:
1. One byte for the length of the password.
2. The variable-length password.
3. Four bytes for the start address.
4. Four bytes for the number of bytes to read.

  [ 0x01 ]  [ variable ]  [ 0x04 ]    [ 0x04 ]
-------------------------------------------------
| PW Length | Password | Start Addr | Num Bytes |
-------------------------------------------------
"""
import sys
import json
import serial
import struct
import argparse

from simon import SimonCipher
from Crypto.Hash import SHA256

RESP_OK = b'\x00'
RESP_ERROR = b'\x01'

def construct_request(start_address, num_bytes):
    # Read in secret password from file
    SECRET_PASSWORD = ''
    SIMON_KEY = ''
    try:
        with open('secret_configure_output.txt', 'rb') as secret_file:
	        jsonLine = json.loads(secret_file.read())
	        SECRET_PASSWORD = jsonLine["password"]
	        SIMON_KEY = jsonLine["SIMONKEY"]
    except:
        print("File not found")
        pass

    # Encrypt and create the frames
    simon = SimonCipher(int(my_simon_key, 16), key_size=128, block_size=64)
    frame1 = simon.encrypt(int(SECRET_PASSWORD[0:16], 16))
    frame2 = simon.encrypt(int(SECRET_PASSWORD[17:32], 16))
    frame3 = simon.encrypt(int(SECRET_PASSWORD[33:48], 16))
    frame4 = simon.encrypt(int(SECRET_PASSWORD[49:64], 16))

    encrypted_start_address = simon.encrypt(start_address)  # Encrypt the start address
    encrypted_num_bytes = simon.encrypt(num_bytes)  # Encrypt the number of bytes

    # Pack the frames together
    package = struct.pack('>QQQQQQ', frame1, frame2, frame3, frame4, encrypted_start_address, encrypted_num_bytes) 
    h = SHA256.new()
    h.update(package)
    package_hash = h.hexdigest()  # Generate the package hash digest
    package = struct.pack('>QQQQQQ64s',  frame1, frame2, frame3, frame4, encrypted_start_address, encrypted_num_byte, package_hash) 

    print("Package Hash: " + package_hash)
    print(str(struct.unpack('>QQQQQQ64s', package)))
    return package

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Memory Readback Tool')
    parser.add_argument("--port", help="Serial port to send update over.", required=True)
    parser.add_argument("--address", help="First address to read from.", required=True)
    parser.add_argument("--num-bytes", help="Number of bytes to read.", required=True)
    parser.add_argument("--datafile", help="File to write data to (optional).")
    args = parser.parse_args()

    request = construct_request(int(args.address), int(args.num_bytes))

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    ser = serial.Serial(args.port, baudrate=115200, timeout=2)

    # Wait for bootloader to reset/enter readback mode.
    print("Waiting for bootloader...")
    while ser.read(1) != 'R':
        pass

    # Send the request.
    ser.write(request)

    # Read the data and write it to stdout (hex encoded).
    data = ser.read(int(args.num_bytes))
    print(data.encode('hex'))

    # Write raw data to file (optional).
    if args.datafile:
        with open(args.datafile, 'wb+') as datafile:
            datafile.write(data)
