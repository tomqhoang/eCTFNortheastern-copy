#!/usr/bin/env python

"""
Memory Readback Tool
A frame consists of four sections:
1. Thirty two bytes for the password.
2. Eight bytes for the start address.
3. Eight bytes for the number of bytes to read.
4. Thirty two bytes for SHA256 representation.

Total is 80 bytes

[ 0x20 ]  [ 0x08 ]    [ 0x08 ]   [ 0x20 ]
-------------------------------------------------
 Password | Start Addr | Num Bytes | SHA256
-------------------------------------------------
"""
import sys
import json
import serial
import struct
import argparse
import binascii

from simon import SimonCipher
from hashlib import sha256

RESP_OK = b'\x00'
RESP_ERROR = b'\x01'

# Swaps bytes in a list, see StackOverflow
def swap_order(d, wsz=4, gsz=2 ):
        return "".join(["".join([m[i:i+gsz] for i in range(wsz-gsz,-gsz,-gsz)]) for m in [d[i:i+wsz] for i in range(0,len(d),wsz)]])

def encrypt(value, simon):
    """
    This is a function that encrypts a value with len(value) 0 to 16
    to a 16 char encrypted string
    Param
    ---------
    value : int or string
        value to encrypt
    simon : SimonCipher
        Cipher used to encrypt data
    Returns
    ----------
    sting
        encrypted string
    """
    # Encrypt and create the frames to pack
    value = str(value)
    if len(value) > 16 and len(value) < 0:
        print "Not a valid value length"
        sys.exit(1)
    #print("original val: "+ value.zfill(16))
    valueSwapped = swap_order(value.zfill(16),wsz=16,gsz=2)
    #print("swapped val: "+ valueSwapped)
    valueEncrypted = hex(simon.encrypt(int(valueSwapped,16)))[2:-1]  # Encrypt the start address
    valueFinal = swap_order(valueEncrypted.zfill(16),wsz=16,gsz=2)
    #print("valueFinal : "+ valueFinal)
    return valueFinal

def construct_request(start_address, num_bytes):
    """
    function that constructs request package
    Param
    -------
    start_address: int
        the start of the memory address
    num_bytes: int
        the number of bytes to return
    Returns:
    package
        ready to send package
    """
    # Read in secret password from file
    SECRET_PASSWORD = ''
    SIMON_KEY = ''
    try:
        with open('secret_configure_output.txt', 'rb') as secret_file:
	    # Load the secret file into a python dictionary
            jsonDict = json.loads(secret_file.read())
            SECRET_PASSWORD = jsonDict["password"]
            SIMON_KEY = jsonDict["SIMONKEY"]
    except:
        print("File not found")
        pass

    # Encrypt and create the frames
    first_keyq = swap_order(SIMON_KEY[0:8], wsz=8, gsz=2)
    second_keyq = swap_order(SIMON_KEY[8:16], wsz=8, gsz=2)
    third_keyq = swap_order(SIMON_KEY[16:24], wsz=8, gsz=2)
    fourth_keyq = swap_order(SIMON_KEY[24:32], wsz=8, gsz=2)
    # Reverse order of chunks to play nice with simon library
    swap_key = fourth_keyq + third_keyq + second_keyq + first_keyq

    # Create a SimonCipher object with a key, keysize, and blocksize
    simon = SimonCipher(int(swap_key, 16), key_size=128, block_size=64)

    # Encrypt frame by frame using simon
    block1 = encrypt(SECRET_PASSWORD[0:16], simon)
    block2 = encrypt(SECRET_PASSWORD[16:32], simon)
    block3 = encrypt(SECRET_PASSWORD[32:48], simon)
    block4 = encrypt(SECRET_PASSWORD[48:], simon)

    # Encrypt the initial memory location
    memory_location = encrypt(start_address, simon)
    # Encrypt the number of bytes that we want to read
    length_data = encrypt(num_bytes, simon)
    # Combine the 4 sections, start address, and number of bytes into one package
    complete_package = block1 + block2 + block3 + block4 + memory_location + length_data
    print("FINAL FRAME : " + complete_package)
    print("Final frame length: " + str(len(complete_package)))
    print("Frame type: " + str(type(complete_package)))

    # Generate hash of final packaged data
    final_package_hash = sha256(complete_package.decode('hex')).hexdigest().zfill(64)

    print("HASH : " + final_package_hash)
    print("Hash type: " + str(type(final_package_hash)))
    package_hash = final_package_hash
    #Big Endian 48byte for final frame and 32byte for hash
    package = struct.pack('>48s32s',  binascii.unhexlify(complete_package), binascii.unhexlify(package_hash))
    print("Package Hash: " + package_hash)
    a, b = struct.unpack('>48s32s', package)
    print("password, start address, num_bytes : " + binascii.hexlify(a))
    print("SHA : " + binascii.hexlify(b))
    return package

if __name__ == '__main__':
    """
    Main Function
    """
    parser = argparse.ArgumentParser(description='Memory Readback Tool')
    parser.add_argument("--port", help="Serial port to send update over.", required=True)
    parser.add_argument("--address", help="First address to read from.", required=True)
    parser.add_argument("--num-bytes", help="Number of bytes to read.", required=True)
    parser.add_argument("--datafile", help="File to write data to (optional).")
    args = parser.parse_args()

    request = construct_request(int(args.address), int(args.num_bytes))

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    ser = serial.Serial(args.port, baudrate=115200, timeout=2)

    # Wait for bootloader to reset/enter readback mode.
    print("Waiting for bootloader...")
    while ser.read(1) != 'R':
        pass

    # Send the request.
    ser.write(request)

    # Read the data and write it to stdout (hex encoded).
    data = ser.read(int(args.num_bytes))
    print(data.encode('hex'))

    # Write raw data to file (optional).
    if args.datafile:
        with open(args.datafile, 'wb+') as datafile:
            datafile.write(data)
